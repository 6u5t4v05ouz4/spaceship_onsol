/**
 * ProjectileManager - Gerencia todos os aspectos dos proj√©teis
 * Responsabilidades:
 * - Cria√ß√£o e disparo de proj√©teis
 * - Movimento e anima√ß√£o
 * - Trail effects
 * - Limpeza autom√°tica
 * - Integra√ß√£o com CollisionManager
 */
export default class ProjectileManager {
    constructor(scene, collisionManager) {
        this.scene = scene;
        this.collisionManager = collisionManager;
        
        // Estado dos proj√©teis
        this.projectiles = [];
        this.maxProjectiles = 50; // Limite para performance
        
        // Configura√ß√µes de disparo
        this.projectileSpeed = 800;
        this.projectileLifetime = 3000; // 3 segundos
        this.projectileScale = 0.6;
        
        // Configura√ß√µes de movimento
        this.manualSpeed = 12; // Exatamente igual ao GameScene antigo
        
        // Refer√™ncia para nave do jogador
        this.playerShip = null;
        
        // Efeitos
        this.particleEffects = null;
        this.audioManager = null;
        this.juiceManager = null;
        
        console.log('üí• ProjectileManager inicializado');
    }
    
    /**
     * Inicializa o sistema de proj√©teis
     */
    initialize(playerShip, particleEffects, audioManager, juiceManager) {
        this.playerShip = playerShip;
        this.particleEffects = particleEffects;
        this.audioManager = audioManager;
        this.juiceManager = juiceManager;
        
        console.log('üí• ProjectileManager: Sistema inicializado');
    }
    
    /**
     * Dispara um proj√©til da nave do jogador
     * C√ìPIA EXATA do GameScene antigo que funcionava
     */
    fireProjectile() {
        if (!this.playerShip) {
            console.warn('‚ö†Ô∏è ProjectileManager: Nave do jogador n√£o dispon√≠vel');
            return;
        }
        
        // Verifica limite de proj√©teis
        if (this.projectiles.length >= this.maxProjectiles) {
            console.log('üí• Limite de proj√©teis atingido');
            return;
        }
        
        try {
            // Recuo leve da nave (juice!) - EXATO do GameScene antigo
            if (this.juiceManager) {
                this.juiceManager.screenShake(40, 1);
            }
            
            // Cria um novo proj√©til (minibullet) na posi√ß√£o da nave - EXATO do GameScene antigo
            // Calcula primeiro o √¢ngulo de disparo para garantir que o sprite fique alinhado √† dire√ß√£o
            const angle = this.playerShip.rotation - Math.PI/2;
            const offsetX = Math.cos(angle) * 30;
            const offsetY = Math.sin(angle) * 30;
            
            // Usa o atlas 'minibullet' para os tiros atuais - EXATO do GameScene antigo
            const projectile = this.scene.physics.add.sprite(
                this.playerShip.x + offsetX,
                this.playerShip.y + offsetY,
                'minibullet',
                'minibullet 0.aseprite'
            );
            
            projectile.setScale(0.6);
            projectile.setDepth(1);
            projectile.setOrigin(0.5, 0.5);
            projectile.body.setAllowGravity(false);
            projectile.setCollideWorldBounds(false);
            
            // Define propriedades do proj√©til
            projectile.isAlive = true;

            // Define a rota√ß√£o do proj√©til igual ao √¢ngulo de movimento (corrige orienta√ß√£o "deitada") - EXATO do GameScene antigo
            projectile.rotation = angle;

            // Desabilita f√≠sica para usar apenas movimento manual
            projectile.body.setEnable(false);

            // Adiciona ao sistema de colis√µes
            if (this.collisionManager) {
                this.collisionManager.addToGroup('projectiles', projectile);
            }

            // Tamb√©m define propriedades de movimento manual para compatibilidade com o loop de update - EXATO do GameScene antigo
            const manualSpeed = 12; // pixels por frame
            projectile.speedX = Math.cos(angle) * manualSpeed;
            projectile.speedY = Math.sin(angle) * manualSpeed;

            // Cria/usa anima√ß√£o do minibullet - EXATO do GameScene antigo
            if (!this.scene.anims.exists('minibullet_anim')) {
                this.scene.anims.create({
                    key: 'minibullet_anim',
                    frames: [
                        { key: 'minibullet', frame: 'minibullet 0.aseprite' },
                        { key: 'minibullet', frame: 'minibullet 1.aseprite' }
                    ],
                    frameRate: 12,
                    repeat: -1
                });
            }

            projectile.play('minibullet_anim');
            
            // Adiciona trilha de part√≠culas ao proj√©til (otimizado) - EXATO do GameScene antigo
            if (this.particleEffects) {
                const trailId = this.particleEffects.createProjectileTrail(projectile);
                projectile._trailId = trailId; // Armazena para limpar depois
            }
            
            // Armazena refer√™ncia
            this.projectiles.push(projectile);
            
            // Remove o proj√©til ap√≥s 3 segundos com efeitos de explos√£o
            this.scene.time.delayedCall(3000, () => {
                if (projectile && projectile.active) {
                    this.destroyProjectile(projectile, true); // Com efeitos de explos√£o
                }
            });
            
            console.log(`üí• Proj√©til disparado (m√©todo exato do GameScene antigo) - √Çngulo: ${(angle * 180 / Math.PI).toFixed(1)}¬∞`);
            
        } catch (error) {
            console.error('‚ùå Erro ao disparar proj√©til:', error);
        }
    }
    
    /**
     * Calcula dados do proj√©til (posi√ß√£o, dire√ß√£o, etc.)
     * Baseado no GameScene antigo que funcionava
     */
    calculateProjectileData() {
        // Usa exatamente a mesma l√≥gica do GameScene antigo
        const angle = this.playerShip.rotation - Math.PI / 2;
        const offsetX = Math.cos(angle) * 30;
        const offsetY = Math.sin(angle) * 30;
        
        console.log('üéØ Proj√©til (baseado no GameScene antigo):', {
            shipRotation: this.playerShip.rotation.toFixed(3),
            shipRotationDegrees: (this.playerShip.rotation * 180 / Math.PI).toFixed(1),
            calculatedAngle: angle.toFixed(3),
            angleDegrees: (angle * 180 / Math.PI).toFixed(1),
            offsetX: offsetX.toFixed(1),
            offsetY: offsetY.toFixed(1),
            spawnX: (this.playerShip.x + offsetX).toFixed(1),
            spawnY: (this.playerShip.y + offsetY).toFixed(1),
            speedX: (Math.cos(angle) * this.manualSpeed).toFixed(1),
            speedY: (Math.sin(angle) * this.manualSpeed).toFixed(1)
        });
        
        return {
            x: this.playerShip.x + offsetX,
            y: this.playerShip.y + offsetY,
            angle: angle,
            speedX: Math.cos(angle) * this.manualSpeed,
            speedY: Math.sin(angle) * this.manualSpeed
        };
    }
    
    /**
     * Cria o sprite do proj√©til
     */
    createProjectile(data) {
        const projectile = this.scene.physics.add.sprite(
            data.x, data.y,
            'minibullet',
            'minibullet 0.aseprite'
        );
        
        // Configura propriedades visuais
        projectile.setScale(this.projectileScale);
        projectile.setDepth(1);
        projectile.setOrigin(0.5, 0.5);
        projectile.rotation = data.angle; // Usa o mesmo √¢ngulo do movimento
        
        console.log('üéØ Rota√ß√£o do proj√©til:', {
            angle: data.angle,
            angleDegrees: (data.angle * 180 / Math.PI).toFixed(1),
            projectileRotation: projectile.rotation,
            projectileRotationDegrees: (projectile.rotation * 180 / Math.PI).toFixed(1)
        });
        
        // Configura propriedades f√≠sicas (igual ao GameScene antigo)
        projectile.body.setAllowGravity(false);
        projectile.setCollideWorldBounds(false);
        
        // Armazena dados de movimento
        projectile.speedX = data.speedX;
        projectile.speedY = data.speedY;
        projectile.angle = data.angle;
        
        // Propriedades do proj√©til
        projectile.isAlive = true;
        projectile.damage = 25; // Dano padr√£o
        
        return projectile;
    }
    
    /**
     * Configura movimento do proj√©til
     * Baseado no GameScene antigo que funcionava
     */
    setupProjectileMovement(projectile, data) {
        // Desabilita f√≠sica para usar movimento manual
        projectile.body.setEnable(false);
        
        console.log('üöÄ Configura√ß√£o do movimento manual:', {
            angle: data.angle,
            angleDegrees: (data.angle * 180 / Math.PI).toFixed(1),
            speedX: data.speedX.toFixed(1),
            speedY: data.speedY.toFixed(1),
            manualSpeed: this.manualSpeed
        });
        
        // Cria anima√ß√£o do proj√©til se n√£o existir
        this.ensureProjectileAnimation();
        
        // Inicia anima√ß√£o
        projectile.play('minibullet_anim');
    }
    
    /**
     * Garante que a anima√ß√£o do proj√©til existe
     */
    ensureProjectileAnimation() {
        if (!this.scene.anims.exists('minibullet_anim')) {
            this.scene.anims.create({
                key: 'minibullet_anim',
                frames: [
                    { key: 'minibullet', frame: 'minibullet 0.aseprite' },
                    { key: 'minibullet', frame: 'minibullet 1.aseprite' }
                ],
                frameRate: 12,
                repeat: -1
            });
        }
    }
    
    /**
     * Adiciona trail effect ao proj√©til
     */
    addTrailEffect(projectile) {
        if (this.particleEffects) {
            const trailId = this.particleEffects.createProjectileTrail(projectile);
            projectile._trailId = trailId;
            console.log(`üí• Trail effect adicionado: ${trailId}`);
        }
    }
    
    /**
     * Configura destrui√ß√£o autom√°tica do proj√©til
     */
    setupProjectileDestruction(projectile) {
        this.scene.time.delayedCall(this.projectileLifetime, () => {
            if (projectile && projectile.active) {
                this.destroyProjectile(projectile);
            }
        });
    }
    
    /**
     * Atualiza todos os proj√©teis
     */
    update() {
        console.log(`üöÄ ProjectileManager: Update chamado - ${this.projectiles.length} proj√©teis`);
        
        this.projectiles.forEach((projectile, index) => {
            if (projectile.active && projectile.isAlive) {
                console.log(`üöÄ Proj√©til ${index}: Ativo e vivo, atualizando movimento`);
                this.updateProjectileMovement(projectile);
                this.updateTrailEffect(projectile);
            } else {
                console.log(`üöÄ Proj√©til ${index}: Inativo ou morto - Active: ${projectile.active}, isAlive: ${projectile.isAlive}`);
            }
        });
    }
    
    /**
     * Atualiza movimento do proj√©til (movimento manual para melhor controle)
     */
    updateProjectileMovement(projectile) {
        if (projectile.speedX !== undefined && projectile.speedY !== undefined) {
            const oldX = projectile.x;
            const oldY = projectile.y;
            
            projectile.x += projectile.speedX;
            projectile.y += projectile.speedY;
            
            // Debug do movimento (sempre por enquanto)
            console.log('üöÄ Movimento do proj√©til:', {
                oldX: oldX.toFixed(1),
                oldY: oldY.toFixed(1),
                newX: projectile.x.toFixed(1),
                newY: projectile.y.toFixed(1),
                speedX: projectile.speedX.toFixed(1),
                speedY: projectile.speedY.toFixed(1),
                isAlive: projectile.isAlive,
                active: projectile.active
            });
        } else {
            console.log('‚ö†Ô∏è Proj√©til sem speedX/Y:', {
                speedX: projectile.speedX,
                speedY: projectile.speedY,
                isAlive: projectile.isAlive,
                active: projectile.active
            });
        }
    }
    
    /**
     * Atualiza trail effect do proj√©til
     * Nota: O trail segue automaticamente o proj√©til via 'follow' property
     */
    updateTrailEffect(projectile) {
        // O trail effect segue automaticamente o proj√©til
        // N√£o √© necess√°rio atualizar manualmente
    }
    
    /**
     * Destr√≥i um proj√©til espec√≠fico com efeitos de explos√£o
     */
    destroyProjectile(projectile, createExplosion = true) {
        if (!projectile || !projectile.isAlive) return;

        console.log('üí• Proj√©til destru√≠do com efeitos');

        projectile.isAlive = false;

        // Cria efeitos de explos√£o (se solicitado)
        if (createExplosion) {
            this.createProjectileExplosion(projectile);
        }

        // Remove trail effect
        if (projectile._trailId && this.particleEffects) {
            this.particleEffects.removeEmitter(projectile._trailId);
        }

        // Remove do sistema de colis√µes
        if (this.collisionManager) {
            this.collisionManager.removeFromGroup('projectiles', projectile);
        }

        // Destr√≥i o sprite
        if (projectile.active) {
            projectile.destroy();
        }

        // Remove da lista
        const index = this.projectiles.indexOf(projectile);
        if (index > -1) {
            this.projectiles.splice(index, 1);
        }
    }

    /**
     * Cria efeitos de explos√£o para proj√©teis
     */
    createProjectileExplosion(projectile) {
        // Anima√ß√£o de explos√£o (baseado no CollisionManager)
        if (this.scene && this.scene.textures.exists('explosion')) {
            const explosion = this.scene.add.sprite(projectile.x, projectile.y, 'explosion');
            explosion.setDepth(100);

            // Usa a anima√ß√£o de explos√£o existente ou cria uma nova
            if (this.scene.anims.exists('explosion_anim')) {
                explosion.play('explosion_anim');
            } else {
                // Cria anima√ß√£o de explos√£o se n√£o existir
                this.createExplosionAnimation();
                explosion.play('explosion_anim');
            }

            explosion.once('animationcomplete', () => {
                explosion.destroy();
            });
        }

        // Efeito de part√≠culas de explos√£o pequena
        if (this.particleEffects) {
            this.particleEffects.createExplosion(projectile.x, projectile.y, 'small');
        }

        // Efeito de impacto (fa√≠scas)
        if (this.particleEffects) {
            this.particleEffects.createImpactSparks(
                projectile.x, projectile.y,
                Phaser.Math.RadToDeg(projectile.rotation || 0)
            );
        }

        // Screen shake pequeno
        if (this.juiceManager) {
            this.juiceManager.screenShake(30, 1);
        }

        // Som de explos√£o pequena
        if (this.audioManager) {
            this.audioManager.playExplosion('small');
        }
    }

    /**
     * Cria anima√ß√£o de explos√£o (baseado no GameSceneModular)
     */
    createExplosionAnimation() {
        if (this.scene.anims.exists('explosion_anim')) return;

        let explosionFrameNames = this.scene.textures.exists('explosion') ?
            this.scene.textures.get('explosion').getFrameNames().filter(n => n !== '__BASE') : [];

        explosionFrameNames = explosionFrameNames.sort((a, b) => {
            const ra = a.match(/(\d+)/g);
            const rb = b.match(/(\d+)/g);
            const na = ra ? parseInt(ra[ra.length-1], 10) : 0;
            const nb = rb ? parseInt(rb[rb.length-1], 10) : 0;
            return na - nb;
        });

        if (explosionFrameNames.length > 0) {
            const explosionFrames = explosionFrameNames.map(fn => ({ key: 'explosion', frame: fn }));

            this.scene.anims.create({
                key: 'explosion_anim',
                frames: explosionFrames,
                frameRate: 15,
                repeat: 0
            });
        }
    }
    
    /**
     * Destr√≥i todos os proj√©teis
     */
    destroyAllProjectiles() {
        console.log('üí• Destruindo todos os proj√©teis');
        
        this.projectiles.forEach(projectile => {
            this.destroyProjectile(projectile);
        });
        
        this.projectiles = [];
    }
    
    /**
     * Limpeza de proj√©teis distantes
     */
    cleanupDistantProjectiles() {
        if (!this.playerShip) return;
        
        const cleanupRadius = 2000; // Raio de limpeza
        
        this.projectiles.forEach((projectile, index) => {
            if (projectile.active) {
                const distance = Phaser.Math.Distance.Between(
                    this.playerShip.x, this.playerShip.y, 
                    projectile.x, projectile.y
                );
                
                if (distance > cleanupRadius) {
                    console.log('üí• Removendo proj√©til distante');
                    this.destroyProjectile(projectile);
                }
            }
        });
    }
    
    /**
     * Aplica culling para otimiza√ß√£o
     */
    cullProjectiles() {
        if (!this.playerShip) return;
        
        const sx = this.playerShip.x;
        const sy = this.playerShip.y;
        const cullRadius = 1200;
        const cullRadiusSquared = cullRadius * cullRadius;
        
        this.projectiles.forEach(projectile => {
            if (!projectile) return;
            
            const dx = projectile.x - sx;
            const dy = projectile.y - sy;
            const distanceSquared = dx * dx + dy * dy;
            const isVisible = distanceSquared <= cullRadiusSquared;
            
            // Atualiza visibilidade
            projectile.setVisible(isVisible);
            
            if (projectile.body) {
                projectile.body.enable = isVisible;
            }
            
            projectile.active = isVisible;
            
            // Trail effect segue automaticamente o proj√©til
            // N√£o √© necess√°rio atualizar manualmente
            
            // Destr√≥i se muito distante
            if (distanceSquared > (cullRadius * 2) * (cullRadius * 2)) {
                this.destroyProjectile(projectile);
            }
        });
    }
    
    /**
     * Obt√©m lista de proj√©teis vivos
     */
    getAliveProjectiles() {
        return this.projectiles.filter(projectile => projectile.active && projectile.isAlive);
    }
    
    /**
     * Obt√©m contagem de proj√©teis
     */
    getProjectileCount() {
        return this.projectiles.length;
    }
    
    /**
     * Configura par√¢metros de disparo
     */
    setProjectileParameters(params) {
        if (params.projectileSpeed !== undefined) this.projectileSpeed = params.projectileSpeed;
        if (params.projectileLifetime !== undefined) this.projectileLifetime = params.projectileLifetime;
        if (params.projectileScale !== undefined) this.projectileScale = params.projectileScale;
        if (params.maxProjectiles !== undefined) this.maxProjectiles = params.maxProjectiles;
        
        console.log('üí• Par√¢metros de proj√©til atualizados:', params);
    }
    
    /**
     * Cria proj√©til especial (para efeitos especiais)
     */
    createSpecialProjectile(x, y, angle, options = {}) {
        const projectile = this.scene.physics.add.sprite(x, y, 'minibullet', 'minibullet 0.aseprite');
        
        // Configura√ß√µes especiais
        const scale = options.scale || this.projectileScale;
        const speed = options.speed || this.projectileSpeed;
        const lifetime = options.lifetime || this.projectileLifetime;
        const damage = options.damage || 25;
        
        projectile.setScale(scale);
        projectile.setDepth(1);
        projectile.setOrigin(0.5, 0.5);
        projectile.rotation = angle;
        projectile.body.setAllowGravity(false);
        projectile.setCollideWorldBounds(false);
        
        // Propriedades
        projectile.speedX = Math.cos(angle) * this.manualSpeed;
        projectile.speedY = Math.sin(angle) * this.manualSpeed;
        projectile.angle = angle;
        projectile.isAlive = true;
        projectile.damage = damage;
        
        // Movimento
        projectile.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);
        projectile.play('minibullet_anim');
        
        // Trail effect
        if (this.particleEffects) {
            projectile._trailId = this.particleEffects.createProjectileTrail(projectile);
        }
        
        // Adiciona ao sistema
        if (this.collisionManager) {
            this.collisionManager.addToGroup('projectiles', projectile);
        }
        
        this.projectiles.push(projectile);
        
        // Destrui√ß√£o autom√°tica
        this.scene.time.delayedCall(lifetime, () => {
            if (projectile && projectile.active) {
                this.destroyProjectile(projectile);
            }
        });
        
        console.log(`üí• Proj√©til especial criado`);
        return projectile;
    }
    
    /**
     * Destr√≥i o manager e limpa recursos
     */
    destroy() {
        console.log('üí• ProjectileManager: Destruindo...');
        
        // Destr√≥i todos os proj√©teis
        this.destroyAllProjectiles();
        
        console.log('‚úÖ ProjectileManager: Destru√≠do');
    }
}
